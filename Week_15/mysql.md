结构
连接器：管理连接
查询缓存：只要有表更新，就会清空该表的查询缓存，极不稳定
分析器：词法分析，语法分析
优化器：执行计划生成，索引选择
执行器：操作引擎，返回结果
存储引擎：innoDB（默认），MyISAM，Memory
日志
redolog（重做日志）：innoDB日志，循环写
binlog（归档日志）：MySQLserver层日志，持久化到磁盘，可用做数据恢复
两阶段提交：过程是存储引擎先写入redolog记为prepare状态，再在执行器生成binlog，最终落盘，redolog状态改为commit
事务隔离级别
读未提交
读提交
可重复读：innoDB默认的隔离事务，开始前会对数据打一个快照
串行化
索引
哈希索引：key-value，联想hashmap的数据结构，适合等值
有序数组索引：适合等值和范围查找，更新比较慢，适合不用更改的历史数据
二叉树:
N叉树：
B树：和B+的区别就在于，B树每个节点都存有数据，导致每节点页的K-V不多，而B+只有叶子节点页存数据，那么一个节点页就能达到1170个k-v
B+树：建议树高不要超过3层，一个节点页16k，一个bigint的主键，长度8字节+指针6字节，16kb/14b=1170，一个叶子节点可以存放1170个K-V，树高3层时，假设一条数据1kb，叶子节点页可以存放16条数据，1170*1170*16=21902400（2千万条）
叶子节点页分裂：自增主键顺序写很好的避免了这个问题，非自增的索引就得导致B+树叶子节点页分裂
聚簇索引和非聚簇索引
聚簇：叶子节点保存的是整行数据（主键索引）
非聚簇：叶子节点保存的是主键
回表：某个索引是非聚簇索引，它的叶子节点存的主键，再根据主键去主键索引查找数据
覆盖索引：select字段和where字段全部包含在某个联合索引中，那么避免了回表
最左匹配原则：（a,b,c）联合索引，可以加速 a    a,b    a,b,c包括字段的最左原则，解释了like ‘aa%’可以被加速，同时可以把较大字段放在前面，节约去单独创建的空间
索引下推：基于联合索引，如果where中的字段存在于索引字段中，那么可以直接判断条件是否满足，不用再回表进行查询比较
普通索引：在等值查找时，会比唯一索引多一次查找；对于更新操作，如果数据页在内存中就直接更新，如果没有，写到change_buffer里面，等下次查询到该数据页时，把数据页读到内存，同时执行change_buffer有关数据页的操作，这个过程叫merge，系统也会定时merge。类似于批处理
唯一索引：在等值查找时，找到结果直接返回；对于更新，由于需要判断唯一性，一定要取一次数据
锁
全局锁：flush tables with read lock ，整库备份使用，在连接断开后会自动释放，（innoDB备份时可以开启single-transaction快照功能，可以不用FTWRL）
表锁：
表锁：lock tabes T1 read/write; unlock T1
元数据锁：表数据增删改查是默认加上该读锁，表结构变更时加写锁，读读不互斥，读写、写写互斥；有个场景就是在数据库数据有个长事务的时候，更改表结构是会阻塞后续的数据库增删改查也会被阻塞，这个时候可以再alter table的时候加个等待时间，及时释放锁。
行锁：执行update的时候就会加上行锁，直到commit后才会释放
change_buffer和redolog
change_buffer：主要节省随机读的IO消耗
redolog：主要解决随机写的IO消耗
为什么表数据删掉之后，表文件大小不变
delete 只是把数据槽清空，然后标记为复用，空间并未重排，需要alter table T engine = innoDB，5.6版本支持online模式不会暂停增删改
count(字段)<count(id)<count(1)≈count(*)
order by 原理
单一索引，先查出来到临时表，然后排序，输出到结果集
rowid排序会导致回表
联合索引，实现覆盖索引，最快但是维护麻烦，显示很难有这种理想状态
不走索引的例子
where 函数运算
like %aaa%，违反最左原则
隐式类型转换
两个表字符集不同，join时候隐式转换字符集
诡异的例子，优化器记录的行数，官方误差有40%-50%，有时候优化器误判认为走主键扫描会比索引更快
查询一条慢
等表锁
等行锁
事务开始还未查询，其他事务更新这条记录产生了很多版本日志，当前事务查询的时候要每个版本回滚回去。
间隙锁和next-key lock
间隙锁：在可重复读下才有间隙锁
next-key lock：前开后闭，遇到等值优化的时候，右开区间，可以认为就是行锁加间隙锁
日志写入过程
binlog：binlog cache(每个事务都有)->写到文件系统的page cache->落盘，可以设置0~N积累多少binlogcache再落盘
redolog：redolog buffer（全局）->page cache->落盘，0每次事务只放到buffer，1每次事务都落盘，2每次事务放到page cache，innoDB会每隔1秒把buffer到落盘，buffer超过一半是会强制落盘，还有一种是做顺风车捎带一起落盘
主从复制
5.6开始就是多线程，conditionor在分发策略中同一行的事务会给同一个worker，一个事务必须始终由一个worker完成