redis特点：读写性能优异，能达到10万QPS，支持持久化，单个操作原子性，命令的消费单线程，主从，集群
为什么要用redis：提高性能：减少不必要的IO时间消耗；高并发：减小下游的并发压力
为什么不使用map、guava：本地缓存，很难实现分布式缓存
为什么redis快：基于内存，数据结构简单，单线程，IO多路复用
数据类型：string，list，set，zset，hash
使用场景：计数器，缓存热点数据，缓存token，分布式锁，求交集并集
RDB：默认持久方式，存到dump.rdb中，配置save参数来调配存储频率（多少秒，完成多少次就进行同步），子进程来完成同步
AOF：存的是命令日志，文件大，支持落盘频率，适合容灾恢复
过期键的删除策略：立即删除，惰性删除，定期删除，redis使用惰性+定期
淘汰策略：当redis内存满了，key淘汰机制，lru移除最近最少使用的key或随机移除某个key
IO多路复用，核心组件：
多路复用程序：监听不同的嵌套字队列，单线程的分发给事件处理器，6.0之后专门为嵌套字的读写开启了异步IO，事件处理还是单线程。
套接字队列
事件分派器
事件处理器
事务的特点：不支持回滚，某个命令出错所有命令都不会执行，通过MULTI、EXEC、DISCARD和WATCH 四个原语实现，一般保证原子性可以使用lua脚本
哨兵+主从：自动故障转移保证高可用
集群部署：16384个槽位，节点通信通过gossip协议
主从复制：初次会先把RDB快照复制过来，进行恢复，在把后续命令给slave
分布式锁：加锁和解锁，加锁（key，谁，不存在才加锁，超期时间），解锁通过lua脚本
雪崩，同一时间大量失效，解决：错开超期时间，失效后第一个请求加锁排队
穿透，不存在缓存数据，解决：value设置为null，布隆过滤器
击穿，大量访问，某个key突然失效，解决：热点数据子线程更新，击穿后加锁
预热
客户端：jedis，lettuce，Redission