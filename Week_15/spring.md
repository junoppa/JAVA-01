spring组成模块：
spring-core、spring-beans、spring-context、spring-jdbc、spring-aop、spring-web、spring-test
spring用常用的设计模式
工厂模式、单例模式、代理模式、模板方法、观察者模式
spring IOC容器
把本该有程序员自己操控对象的事情交给容器来完成，
IOC容器负责创建对象，管理对象（依赖注入DI），装配对象，配置对象，以及整个对象的生命周期；
IOC实现机制：工厂模式+反射
beanFactory和ApplicationContext的区别
ApplicationContext是beanFactory的子接口，在beanFactory的基础上还提供更多的功能；
加载方式：beanFactory是懒加载，ApplicationContext是在容器启动时就加载所有的bean；
创建方式：beanFactory通常用编程的方式被创建，ApplicationContext还可以用声明的方式创建；
注册方式：都支持beanPostProcessor的使用，beanFactory需要手动注册，ApplicationContext自动注册。
依赖注入：在没有ioc来管理这些的时候，bean的注入将是一个特别繁琐的事情，现在全权由IOC容器来处理bean之间的依赖关系
依赖注入的方式：接口注入（废弃），构造器注入，setter注入
spring支持的几种bean作用域：singleton（单例），prototype（多例），request，session，global-session
单例bean是线程安全的吗：不是，这里要排除无状态的bean，有状态的bean就不是的了
bean的生命周期：实例化-属性填充-BeanNameAware.setBeanName-BeanFactoryAware.setBeanFactory-ApplicationContextAware.setApplicationContext-BeanPostProcessor前置方法-initializingBean-BeanPostProcessor后置方法-开始使用bean-DisposableBean.destroy
Bean的自动装配方式：byName，byType，构造函数（参数byType），自动探测
@Autowired：AutowiredAnnotationBeanPostProcessor后置处理器会扫描这一类的注解
JDBCTemplate：模板方法，提供了很多便利的方法
事务的实现方式：编程式，声明式（配置注解和XML），其实最终还是通过数据库的事务来实现。
事务传播行为：
有就加入，没有就创建（最常用的）
有就加入，没有就没有
有就加入，没有抛异常
总是用新事务开启
不用事务，有事务就挂起
不用事务，有事务就抛异常
有事务嵌套执行，没有就创建
事务的隔离级别：未提交读，已提交读，可重复读，序列化，都喜欢折中一点的
AOP：在不影响业务的情况下，进行横向拓展，实现方式就通过代理的方式
静态代理和动态代理：生成代理类的时机，静态是在编译器就生成了，动态是在使用的时候动态的织入
JDK动态代理：只提供接口级别的代理，proxy类，反射的方式获取目标方法，然后编织，invocationHandler最后生成代理对象
CGlib动态代理：通过继承的方式来生成一个子类，并覆盖需要增强的代码。
通知类型：前置，后置，返回，异常，环绕
切面：通知和切点，横切的逻辑定义，也包含连接点的定义
